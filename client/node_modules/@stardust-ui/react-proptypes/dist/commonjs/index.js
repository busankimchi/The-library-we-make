"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ref = exports.design = exports.animation = exports.align = exports.size = exports.accessibility = exports.deprecate = exports.collectionShorthandWithKindProp = exports.collectionShorthand = exports.itemShorthandWithoutJSX = exports.itemShorthandWithKindProp = exports.itemShorthand = exports.shorthandAllowingChildren = exports.wrapperShorthand = exports.nodeContent = exports.multipleProp = exports.demand = exports.givenProps = exports.some = exports.every = exports.disallow = exports.never = exports.suggest = exports.domNode = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _difference2 = _interopRequireDefault(require("lodash/difference"));

var _trim2 = _interopRequireDefault(require("lodash/trim"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _keys2 = _interopRequireDefault(require("lodash/keys"));

var _isPlainObject2 = _interopRequireDefault(require("lodash/isPlainObject"));

var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));

var _compact2 = _interopRequireDefault(require("lodash/compact"));

var _first2 = _interopRequireDefault(require("lodash/first"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _min2 = _interopRequireDefault(require("lodash/min"));

var _sum2 = _interopRequireDefault(require("lodash/sum"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _sortBy2 = _interopRequireDefault(require("lodash/sortBy"));

var _take2 = _interopRequireDefault(require("lodash/take"));

var _memoize2 = _interopRequireDefault(require("lodash/memoize"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _leven = _interopRequireDefault(require("./leven"));

var typeOf = function typeOf(x) {
  return Object.prototype.toString.call(x);
};
/**
 * Ensure a prop is a valid DOM node.
 */


var domNode = function domNode(props, propName) {
  // skip if prop is undefined
  if (props[propName] === undefined) return undefined; // skip if prop is valid

  if (props[propName] instanceof Element) return undefined;
  return new Error("Invalid prop \"".concat(propName, "\" supplied, expected a DOM node."));
};
/**
 * Similar to PropTypes.oneOf but shows closest matches.
 * Word order is ignored allowing `left chevron` to match `chevron left`.
 * Useful for very large lists of options (e.g. Icon name, Flag name, etc.)
 * @param {string[]} suggestions An array of allowed values.
 */


exports.domNode = domNode;

var suggest = function suggest(suggestions) {
  if (!Array.isArray(suggestions)) {
    throw new Error('Invalid argument supplied to suggest, expected an instance of array.');
  }

  var findBestSuggestions = (0, _memoize2.default)(function (str) {
    var propValueWords = str.split(' ');
    return (0, _take2.default)((0, _sortBy2.default)((0, _map2.default)(suggestions, function (suggestion) {
      var suggestionWords = suggestion.split(' ');
      var propValueScore = (0, _sum2.default)((0, _map2.default)((0, _map2.default)(propValueWords, function (x) {
        return (0, _map2.default)(suggestionWords, function (y) {
          return (0, _leven.default)(x, y);
        });
      }), _min2.default));
      var suggestionScore = (0, _sum2.default)((0, _map2.default)((0, _map2.default)(suggestionWords, function (x) {
        return (0, _map2.default)(propValueWords, function (y) {
          return (0, _leven.default)(x, y);
        });
      }), _min2.default));
      return {
        suggestion: suggestion,
        score: propValueScore + suggestionScore
      };
    }), ['score', 'suggestion']), 3);
  }); // Convert the suggestions list into a hash map for O(n) lookup times. Ensure
  // the words in each key are sorted alphabetically so that we have a consistent
  // way of looking up a value in the map, i.e. we can sort the words in the
  // incoming propValue and look that up without having to check all permutations.

  var suggestionsLookup = suggestions.reduce(function (acc, key) {
    acc[key.split(' ').sort().join(' ')] = true;
    return acc;
  }, {});
  return function (props, propName, componentName) {
    var propValue = props[propName]; // skip if prop is undefined or is included in the suggestions

    if (!propValue || suggestionsLookup[propValue]) return undefined; // check if the words were correct but ordered differently.
    // Since we're matching for classNames we need to allow any word order
    // to pass validation, e.g. `left chevron` vs `chevron left`.

    var propValueSorted = propValue.split(' ').sort().join(' ');
    if (suggestionsLookup[propValueSorted]) return undefined; // find best suggestions

    var bestMatches = findBestSuggestions(propValue); // skip if a match scored 0

    if (bestMatches.some(function (x) {
      return x.score === 0;
    })) return undefined;
    return new Error(["Invalid prop `".concat(propName, "` of value `").concat(propValue, "` supplied to `").concat(componentName, "`."), "\n\nInstead of `".concat(propValue, "`, did you mean:"), bestMatches.map(function (x) {
      return "\n  - ".concat(x.suggestion);
    }).join(''), '\n'].join(''));
  };
};
/**
 * The prop cannot be used.
 * Similar to `deprecate` but with different error message.
 */


exports.suggest = suggest;

var never = function never(props, propName, componentName) {
  if ((0, _isNil2.default)(props[propName]) || props[propName] === false) return undefined;
  return new Error("Prop `".concat(propName, "` in `").concat(componentName, "` cannot be used."));
};
/**
 * Disallow other props from being defined with this prop.
 * @param {string[]} disallowedProps An array of props that cannot be used with this prop.
 */


exports.never = never;

var disallow = function disallow(disallowedProps) {
  return function (props, propName, componentName) {
    if (!Array.isArray(disallowedProps)) {
      throw new Error(['Invalid argument supplied to disallow, expected an instance of array.', " See `".concat(propName, "` prop in `").concat(componentName, "`.")].join(''));
    } // skip if prop is undefined


    if ((0, _isNil2.default)(props[propName]) || props[propName] === false) return undefined; // find disallowed props with values

    var disallowed = disallowedProps.reduce(function (acc, disallowedProp) {
      if (!(0, _isNil2.default)(props[disallowedProp]) && props[disallowedProp] !== false) {
        return [].concat((0, _toConsumableArray2.default)(acc), [disallowedProp]);
      }

      return acc;
    }, []);

    if (disallowed.length > 0) {
      return new Error(["Prop `".concat(propName, "` in `").concat(componentName, "` conflicts with props: `").concat(disallowed.join('`, `'), "`."), 'They cannot be defined together, choose one or the other.'].join(' '));
    }

    return undefined;
  };
};
/**
 * Ensure a prop adherers to multiple prop type validators.
 * @param {function[]} validators An array of propType functions.
 */


exports.disallow = disallow;

var every = function every(validators) {
  return function (props, propName, componentName) {
    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    if (!Array.isArray(validators)) {
      throw new Error(['Invalid argument supplied to every, expected an instance of array.', "See `".concat(propName, "` prop in `").concat(componentName, "`.")].join(' '));
    }

    return (0, _first2.default)((0, _compact2.default)((0, _map2.default)(validators, function (validator) {
      if (typeof validator !== 'function') {
        throw new Error("every() argument \"validators\" should contain functions, found: ".concat(typeOf(validator), "."));
      }

      return validator.apply(void 0, [props, propName, componentName].concat(args));
    }))); // we can only return one error at a time
  };
};
/**
 * Ensure a prop adherers to at least one of the given prop type validators.
 * @param {function[]} validators An array of propType functions.
 */


exports.every = every;

var some = function some(validators) {
  return function (props, propName, componentName) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
      args[_key2 - 3] = arguments[_key2];
    }

    if (!Array.isArray(validators)) {
      throw new Error(['Invalid argument supplied to some, expected an instance of array.', "See `".concat(propName, "` prop in `").concat(componentName, "`.")].join(' '));
    }

    var errors = (0, _compact2.default)((0, _map2.default)(validators, function (validator) {
      if (!(0, _isFunction2.default)(validator)) {
        throw new Error("some() argument \"validators\" should contain functions, found: ".concat(typeOf(validator), "."));
      }

      return validator.apply(void 0, [props, propName, componentName].concat(args));
    })); // fail only if all validators failed

    if (errors.length === validators.length) {
      var error = new Error('One of these validators must pass:');
      error.message += "\n".concat((0, _map2.default)(errors, function (err) {
        return "- ".concat(err.message);
      }).join('\n'));
      return error;
    }

    return undefined;
  };
};
/**
 * Ensure a validator passes only when a component has a given propsShape.
 * @param {object} propsShape An object describing the prop shape.
 * @param {function} validator A propType function.
 */


exports.some = some;

var givenProps = function givenProps(propsShape, validator) {
  return function (props, propName, componentName) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
      args[_key3 - 3] = arguments[_key3];
    }

    if (!(0, _isPlainObject2.default)(propsShape)) {
      throw new Error(['Invalid argument supplied to givenProps, expected an object.', "See `".concat(propName, "` prop in `").concat(componentName, "`.")].join(' '));
    }

    if (typeof validator !== 'function') {
      throw new Error(['Invalid argument supplied to givenProps, expected a function.', "See `".concat(propName, "` prop in `").concat(componentName, "`.")].join(' '));
    }

    var shouldValidate = (0, _keys2.default)(propsShape).every(function (key) {
      var val = propsShape[key]; // require propShape validators to pass or prop values to match

      return typeof val === 'function' ? !val.apply(void 0, [props, key, componentName].concat(args)) : val === props[propName];
    });
    if (!shouldValidate) return undefined;
    var error = validator.apply(void 0, [props, propName, componentName].concat(args));

    if (error) {
      // poor mans shallow pretty print, prevents JSON circular reference errors
      var prettyProps = "{ ".concat((0, _keys2.default)((0, _pick2.default)(props, (0, _keys2.default)(propsShape))).map(function (key) {
        var val = props[key];
        var renderedValue = val;
        if (typeof val === 'string') renderedValue = "\"".concat(val, "\"");else if (Array.isArray(val)) renderedValue = "[".concat(val.join(', '), "]");else if ((0, _isObject2.default)(val)) renderedValue = '{...}';
        return "".concat(key, ": ").concat(renderedValue);
      }).join(', '), " }");
      error.message = "Given props ".concat(prettyProps, ": ").concat(error.message);
      return error;
    }
  };
};
/**
 * Define prop dependencies by requiring other props.
 * @param {string[]} requiredProps An array of required prop names.
 */


exports.givenProps = givenProps;

var demand = function demand(requiredProps) {
  return function (props, propName, componentName) {
    if (!Array.isArray(requiredProps)) {
      throw new Error(['Invalid `requiredProps` argument supplied to require, expected an instance of array.', " See `".concat(propName, "` prop in `").concat(componentName, "`.")].join(''));
    } // skip if prop is undefined


    if (props[propName] === undefined) return undefined;
    var missingRequired = requiredProps.filter(function (requiredProp) {
      return props[requiredProp] === undefined;
    });

    if (missingRequired.length > 0) {
      return new Error("`".concat(propName, "` prop in `").concat(componentName, "` requires props: `").concat(missingRequired.join('`, `'), "`."));
    }

    return undefined;
  };
};
/**
 * Ensure an multiple prop contains a string with only possible values.
 * @param {string[]} possible An array of possible values to prop.
 */


exports.demand = demand;

var multipleProp = function multipleProp(possible) {
  return function (props, propName, componentName) {
    if (!Array.isArray(possible)) {
      throw new Error(['Invalid argument supplied to some, expected an instance of array.', "See `".concat(propName, "` prop in `").concat(componentName, "`.")].join(' '));
    }

    var propValue = props[propName]; // skip if prop is undefined

    if ((0, _isNil2.default)(propValue) || propValue === false) return undefined;
    var values = propValue.replace('large screen', 'large-screen').replace(/ vertically/g, '-vertically').split(' ').map(function (val) {
      return (0, _trim2.default)(val).replace('-', ' ');
    });
    var invalid = (0, _difference2.default)(values, possible); // fail only if there are invalid values

    if (invalid.length > 0) {
      return new Error("`".concat(propName, "` prop in `").concat(componentName, "` has invalid values: `").concat(invalid.join('`, `'), "`."));
    }

    return undefined;
  };
};
/**
 * Ensure a component can render as a node passed as a prop value in place of children.
 */


exports.multipleProp = multipleProp;
var nodeContent = every([disallow(['children']), PropTypes.node]);
exports.nodeContent = nodeContent;
var wrapperShorthand = PropTypes.oneOfType([PropTypes.node, PropTypes.object, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.node, PropTypes.object]))]);
/**
 * A shorthand prop which can be used together with `children`.
 */

exports.wrapperShorthand = wrapperShorthand;
var shorthandAllowingChildren = PropTypes.oneOfType([PropTypes.node, PropTypes.object, PropTypes.func]);
/**
 * Item shorthand is a description of a component that can be a literal,
 * a props object, an element or a render function.
 */

exports.shorthandAllowingChildren = shorthandAllowingChildren;
var itemShorthand = every([disallow(['children']), shorthandAllowingChildren]);
exports.itemShorthand = itemShorthand;

var itemShorthandWithKindProp = function itemShorthandWithKindProp(kindPropValues) {
  return every([disallow(['children']), PropTypes.oneOfType([PropTypes.node, PropTypes.shape({
    kind: PropTypes.oneOf(kindPropValues)
  }), PropTypes.func])]);
};

exports.itemShorthandWithKindProp = itemShorthandWithKindProp;
var itemShorthandWithoutJSX = every([disallow(['children']), PropTypes.oneOfType([PropTypes.func, PropTypes.number, PropTypes.object, PropTypes.string, PropTypes.oneOf([false])])]);
/**
 * Collection shorthand ensures a prop is an array of item shorthand.
 */

exports.itemShorthandWithoutJSX = itemShorthandWithoutJSX;
var collectionShorthand = every([disallow(['children']), PropTypes.arrayOf(itemShorthand)]);
exports.collectionShorthand = collectionShorthand;

var collectionShorthandWithKindProp = function collectionShorthandWithKindProp(kindPropValues) {
  return every([disallow(['children']), PropTypes.arrayOf(itemShorthandWithKindProp(kindPropValues))]);
};
/**
 * Show a deprecated warning for component props with a help message and optional validator.
 * @param {string} help A help message to display with the deprecation warning.
 * @param {function} [validator] A propType function.
 */


exports.collectionShorthandWithKindProp = collectionShorthandWithKindProp;

var deprecate = function deprecate(help, validator) {
  return function (props, propName, componentName) {
    if (typeof help !== 'string') {
      throw new Error(['Invalid `help` argument supplied to deprecate, expected a string.', "See `".concat(propName, "` prop in `").concat(componentName, "`.")].join(' '));
    } // skip if prop is undefined


    if (props[propName] === undefined) return undefined; // deprecation error and help

    var error = new Error("The `".concat(propName, "` prop in `").concat(componentName, "` is deprecated."));
    if (help) error.message += " ".concat(help); // add optional validation error message

    if (validator) {
      if (typeof validator === 'function') {
        for (var _len4 = arguments.length, args = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {
          args[_key4 - 3] = arguments[_key4];
        }

        var validationError = validator.apply(void 0, [props, propName, componentName].concat(args));

        if (validationError) {
          error.message = "".concat(error.message, " ").concat(validationError.message);
        }
      } else {
        throw new Error(['Invalid argument supplied to deprecate, expected a function.', "See `".concat(propName, "` prop in `").concat(componentName, "`.")].join(' '));
      }
    }

    return error;
  };
};

exports.deprecate = deprecate;
var accessibility = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
exports.accessibility = accessibility;
var size = PropTypes.oneOf(['smallest', 'smaller', 'small', 'medium', 'large', 'larger', 'largest']);
exports.size = size;
var align = PropTypes.oneOf(['start', 'end', 'center', 'justify']);
exports.align = align;
var animation = PropTypes.oneOfType([// Validator is broken in the latest @react/types
PropTypes.shape({
  name: PropTypes.string.isRequired,
  delay: PropTypes.string,
  direction: PropTypes.string,
  duration: PropTypes.string,
  fillMode: PropTypes.string,
  iterationCount: PropTypes.string,
  playState: PropTypes.string,
  timingFunction: PropTypes.string
}), PropTypes.string]); // Heads Up!
// Keep in sync with packages/react/src/themes/types.ts

exports.animation = animation;
var design = PropTypes.shape({
  position: PropTypes.string,
  display: PropTypes.string,
  top: PropTypes.string,
  right: PropTypes.string,
  bottom: PropTypes.string,
  left: PropTypes.string,
  padding: PropTypes.string,
  paddingTop: PropTypes.string,
  paddingRight: PropTypes.string,
  paddingBottom: PropTypes.string,
  paddingLeft: PropTypes.string,
  margin: PropTypes.string,
  marginTop: PropTypes.string,
  marginRight: PropTypes.string,
  marginBottom: PropTypes.string,
  marginLeft: PropTypes.string,
  width: PropTypes.string,
  height: PropTypes.string,
  minWidth: PropTypes.string,
  maxWidth: PropTypes.string,
  minHeight: PropTypes.string,
  maxHeight: PropTypes.string
});
/** A checker that matches the React.Ref type. */

exports.design = design;
var ref = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
exports.ref = ref;