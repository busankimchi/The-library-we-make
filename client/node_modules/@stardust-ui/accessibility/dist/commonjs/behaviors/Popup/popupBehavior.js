"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _isArray2 = _interopRequireDefault(require("lodash/isArray"));

var keyboardKey = _interopRequireWildcard(require("keyboard-key"));

/**
 * @description
 * Adds tabIndex='0' to 'trigger' slot, if it is not tabbable element and no tabIndex attribute provided.
 *
 * @specification
 * Adds attribute 'aria-disabled=true' to 'trigger' slot if 'disabled' property is true. Does not set the attribute otherwise.
 * Adds attribute 'role=dialog' to 'popup' slot if 'trapFocus' property is true. Sets the attribute to 'complementary' otherwise.
 * Adds attribute 'aria-modal=true' to 'popup' slot if 'trapFocus' property is true. Does not set the attribute otherwise.
 */
var popupBehavior = function popupBehavior(props) {
  var onAsArray = (0, _isArray2.default)(props.on) ? props.on : [props.on];
  return {
    attributes: {
      trigger: Object.assign({}, props.tabbableTrigger ? {
        tabIndex: getAriaAttributeFromProps('tabIndex', props, 0)
      } : undefined, {
        'aria-disabled': props.disabled
      }),
      popup: {
        role: props.trapFocus ? 'dialog' : 'complementary',
        'aria-modal': props.trapFocus ? true : undefined
      }
    },
    keyActions: {
      popup: {
        closeAndFocusTrigger: {
          keyCombinations: [{
            keyCode: keyboardKey.Escape
          }]
        },
        preventScroll: {
          keyCombinations: props.isOpenedByRightClick && (0, _includes2.default)(onAsArray, 'context') && [{
            keyCode: keyboardKey.ArrowDown
          }, {
            keyCode: keyboardKey.ArrowUp
          }, {
            keyCode: keyboardKey.PageDown
          }, {
            keyCode: keyboardKey.PageUp
          }, {
            keyCode: keyboardKey.Home
          }, {
            keyCode: keyboardKey.End
          }]
        }
      },
      trigger: {
        close: {
          keyCombinations: [{
            keyCode: keyboardKey.Escape
          }]
        },
        toggle: {
          keyCombinations: (0, _includes2.default)(onAsArray, 'click') && [{
            keyCode: keyboardKey.Enter
          }, {
            keyCode: keyboardKey.Spacebar
          }]
        },
        open: {
          keyCombinations: (0, _includes2.default)(onAsArray, 'hover') && !(0, _includes2.default)(onAsArray, 'context') && [{
            keyCode: keyboardKey.Enter
          }, {
            keyCode: keyboardKey.Spacebar
          }]
        }
      }
    }
  };
};

var isFocusable = function isFocusable(propsData) {
  try {
    var as = propsData.as,
        href = propsData.href,
        type = propsData.type;
    return type === 'button' || type === 'input' || type === 'a' && href !== undefined || as === 'button';
  } catch (_unused) {
    return false;
  }
};

var getAriaAttributeFromProps = function getAriaAttributeFromProps(attributeName, props, defaultValue) {
  if (!props.trigger) return undefined;

  if (props.trigger.props[attributeName]) {
    return props.trigger.props[attributeName];
  }

  var _props$trigger$props = props.trigger.props,
      as = _props$trigger$props.as,
      href = _props$trigger$props.href;
  var type = props.trigger.type;

  if (isFocusable({
    as: as,
    href: href,
    type: type
  })) {
    return undefined;
  }

  return defaultValue;
};

var _default = popupBehavior;
exports.default = _default;