import _extends from "@babel/runtime/helpers/esm/extends";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _keys from "lodash/keys";
import { EventListener } from '@stardust-ui/react-component-event-listener';
import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as PropTypes from 'prop-types';
import getElementType from '../utils/getElementType';
import getUnhandledProps from '../utils/getUnhandledProps';
import { getNextElement, getFirstTabbable, getLastTabbable, getWindow, getDocument, focusAsync, HIDDEN_FROM_ACC_TREE } from './focusUtilities';

/** FocusTrapZone is used to trap the focus in any html element placed in body
 *  and hide other elements outside of Focus Trap Zone from accessibility tree.
 *  Pressing tab will circle focus within the inner focusable elements of the FocusTrapZone. */
var FocusTrapZone =
/*#__PURE__*/
function (_React$Component) {
  _inherits(FocusTrapZone, _React$Component);

  function FocusTrapZone() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, FocusTrapZone);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(FocusTrapZone)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "_root", {
      current: null
    });

    _defineProperty(_assertThisInitialized(_this), "_previouslyFocusedElementOutsideTrapZone", void 0);

    _defineProperty(_assertThisInitialized(_this), "_previouslyFocusedElementInTrapZone", void 0);

    _defineProperty(_assertThisInitialized(_this), "_firstBumper", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "_lastBumper", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "_hasFocus", false);

    _defineProperty(_assertThisInitialized(_this), "windowRef", React.createRef());

    _defineProperty(_assertThisInitialized(_this), "createRef", function (elem) {
      _this._root.current = ReactDOM.findDOMNode(elem); // @ts-ignore

      _this.windowRef.current = getWindow(_this._root.current);
    });

    _defineProperty(_assertThisInitialized(_this), "shouldHandleOutsideClick", function () {
      return !_this.props.isClickableOutsideFocusTrap || !_this.props.focusTriggerOnOutsideClick;
    });

    _defineProperty(_assertThisInitialized(_this), "_onRootFocus", function (ev) {
      if (_this.props.onFocus) {
        _this.props.onFocus(ev);
      }

      _this._hasFocus = true;
    });

    _defineProperty(_assertThisInitialized(_this), "_onRootBlur", function (ev) {
      if (_this.props.onBlur) {
        _this.props.onBlur(ev);
      }

      var relatedTarget = ev.relatedTarget;

      if (ev.relatedTarget === null) {
        // In IE11, due to lack of support, event.relatedTarget is always
        // null making every onBlur call to be "outside" of the ComboBox
        // even when it's not. Using document.activeElement is another way
        // for us to be able to get what the relatedTarget without relying
        // on the event
        var doc = getDocument(_this._root.current);
        relatedTarget = doc.activeElement;
      }

      if (!_this._root.current.contains(relatedTarget)) {
        _this._hasFocus = false;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_onFirstBumperFocus", function () {
      _this._onBumperFocus(true);
    });

    _defineProperty(_assertThisInitialized(_this), "_onLastBumperFocus", function () {
      _this._onBumperFocus(false);
    });

    _defineProperty(_assertThisInitialized(_this), "_onBumperFocus", function (isFirstBumper) {
      if (!_this._root.current) {
        return;
      }

      var currentBumper = isFirstBumper === _this._hasFocus ? _this._lastBumper.current : _this._firstBumper.current;
      var nextFocusable = isFirstBumper === _this._hasFocus ? getLastTabbable(_this._root.current, currentBumper, true, false) : getFirstTabbable(_this._root.current, currentBumper, true, false);

      if (nextFocusable) {
        if (_this._isBumper(nextFocusable)) {
          // This can happen when FTZ contains no tabbable elements. Focus will take care of finding a focusable element in FTZ.
          _this._findElementAndFocusAsync();
        } else {
          nextFocusable.focus();
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_enableFocusTrapZone", function () {
      var _this$props$disabled = _this.props.disabled,
          disabled = _this$props$disabled === void 0 ? false : _this$props$disabled;

      if (disabled) {
        return;
      }

      FocusTrapZone._focusStack.push(_assertThisInitialized(_this));

      _this._bringFocusIntoZone();

      _this._hideContentFromAccessibilityTree();
    });

    _defineProperty(_assertThisInitialized(_this), "_bringFocusIntoZone", function () {
      var _this$props$disableFi = _this.props.disableFirstFocus,
          disableFirstFocus = _this$props$disableFi === void 0 ? false : _this$props$disableFi;
      _this._previouslyFocusedElementOutsideTrapZone = _this._getPreviouslyFocusedElementOutsideTrapZone();

      if (!_this._root.current.contains(_this._previouslyFocusedElementOutsideTrapZone) && !disableFirstFocus) {
        _this._findElementAndFocusAsync();
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_releaseFocusTrapZone", function () {
      var ignoreExternalFocusing = _this.props.ignoreExternalFocusing;
      FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {
        return _assertThisInitialized(_this) !== value;
      }); // try to focus element which triggered FocusTrapZone - prviously focused element outside trap zone

      var doc = getDocument(_this._root.current);
      var activeElement = doc.activeElement;

      if (!ignoreExternalFocusing && _this._previouslyFocusedElementOutsideTrapZone && (_this._root.current.contains(activeElement) || activeElement === doc.body)) {
        _this._focusAsync(_this._previouslyFocusedElementOutsideTrapZone);
      } // if last active focus trap zone is going to be released - show previously hidden content in accessibility tree


      var lastActiveFocusTrap = FocusTrapZone._focusStack.length && FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1];

      if (!lastActiveFocusTrap) {
        _this._showContentInAccessibilityTree();
      } else if (lastActiveFocusTrap._root.current && lastActiveFocusTrap._root.current.hasAttribute(HIDDEN_FROM_ACC_TREE)) {
        lastActiveFocusTrap._root.current.removeAttribute(HIDDEN_FROM_ACC_TREE);

        lastActiveFocusTrap._root.current.removeAttribute('aria-hidden');
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_findElementAndFocusAsync", function () {
      if (!_this._root.current) {
        return;
      }

      var _this$props = _this.props,
          focusPreviouslyFocusedInnerElement = _this$props.focusPreviouslyFocusedInnerElement,
          firstFocusableSelector = _this$props.firstFocusableSelector;

      if (focusPreviouslyFocusedInnerElement && _this._previouslyFocusedElementInTrapZone && _this._root.current.contains(_this._previouslyFocusedElementInTrapZone)) {
        // focus on the last item that had focus in the zone before we left the zone
        _this._focusAsync(_this._previouslyFocusedElementInTrapZone);

        return;
      }

      var focusSelector = firstFocusableSelector && (typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector());
      var firstFocusableChild = null;

      if (focusSelector) {
        firstFocusableChild = _this._root.current.querySelector(focusSelector);
      } // Fall back to first element if query selector did not match any elements.


      if (!firstFocusableChild) {
        firstFocusableChild = getNextElement(_this._root.current, _this._root.current.firstChild, false, false, false, true);
      }

      firstFocusableChild && _this._focusAsync(firstFocusableChild);
    });

    _defineProperty(_assertThisInitialized(_this), "_onFocusCapture", function (ev) {
      _this.props.onFocusCapture && _this.props.onFocusCapture(ev);

      if (ev.target !== ev.currentTarget && !_this._isBumper(ev.target)) {
        // every time focus changes within the trap zone, remember the focused element so that
        // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))
        _this._previouslyFocusedElementInTrapZone = ev.target;
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_forceFocusInTrap", function (ev, triggeredElement) {
      if (FocusTrapZone._focusStack.length && _assertThisInitialized(_this) === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {
        if (!_this._root.current.contains(triggeredElement)) {
          _this._findElementAndFocusAsync();

          ev.preventDefault();
          ev.stopPropagation();
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_handleOutsideFocus", function (ev) {
      var doc = getDocument(_this._root.current);
      var focusedElement = doc.activeElement;
      focusedElement && _this._forceFocusInTrap(ev, focusedElement);
    });

    _defineProperty(_assertThisInitialized(_this), "_handleOutsideClick", function (ev) {
      var clickedElement = ev.target;
      var _this$props2 = _this.props,
          isClickableOutsideFocusTrap = _this$props2.isClickableOutsideFocusTrap,
          focusTriggerOnOutsideClick = _this$props2.focusTriggerOnOutsideClick;

      if (!isClickableOutsideFocusTrap) {
        clickedElement && _this._forceFocusInTrap(ev, clickedElement);
      } else if (!focusTriggerOnOutsideClick) {
        var isOutsideFocusTrapZone = _this._root.current && !_this._root.current.contains(clickedElement);
        var isOutsideTriggerElement = _this._previouslyFocusedElementOutsideTrapZone && !_this._previouslyFocusedElementOutsideTrapZone.contains(clickedElement);

        if (isOutsideFocusTrapZone && isOutsideTriggerElement) {
          // set it to NULL, so the trigger will not be focused on componentWillUnmount
          _this._previouslyFocusedElementOutsideTrapZone = null;
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_onKeyboardHandler", function (ev) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(ev);
      } // do not propogate keyboard events outside focus trap zone
      // https://github.com/stardust-ui/react/pull/1180


      ev.stopPropagation();
    });

    _defineProperty(_assertThisInitialized(_this), "_getPreviouslyFocusedElementOutsideTrapZone", function () {
      var elementToFocusOnDismiss = _this.props.elementToFocusOnDismiss;
      var previouslyFocusedElement = _this._previouslyFocusedElementOutsideTrapZone;

      if (elementToFocusOnDismiss && previouslyFocusedElement !== elementToFocusOnDismiss) {
        previouslyFocusedElement = elementToFocusOnDismiss;
      } else if (!previouslyFocusedElement) {
        var doc = getDocument(_this._root.current);
        previouslyFocusedElement = doc.activeElement;
      }

      return previouslyFocusedElement;
    });

    _defineProperty(_assertThisInitialized(_this), "_hideContentFromAccessibilityTree", function () {
      var doc = getDocument(_this._root.current);
      var bodyChildren = doc.body && doc.body.children || [];

      if (bodyChildren.length && !doc.body.contains(_this._root.current)) {
        // In case popup render options will change

        /* eslint-disable-next-line no-console */
        console.warn('Body element does not contain trap zone element. Please, ensure the trap zone element is placed inside body, so it will work properly.');
      }

      for (var index = 0; index < bodyChildren.length; index++) {
        var currentChild = bodyChildren[index];
        var isOrHasFocusTrapZone = currentChild === _this._root.current || currentChild.contains(_this._root.current);
        var isAriaLiveRegion = currentChild.hasAttribute('aria-live');

        if (!isOrHasFocusTrapZone && !isAriaLiveRegion && currentChild.getAttribute('aria-hidden') !== 'true') {
          currentChild.setAttribute('aria-hidden', 'true');
          currentChild.setAttribute(HIDDEN_FROM_ACC_TREE, 'true');
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_showContentInAccessibilityTree", function () {
      var doc = getDocument(_this._root.current);
      var hiddenElements = doc.querySelectorAll("[".concat(HIDDEN_FROM_ACC_TREE, "=\"true\"]"));

      for (var index = 0; index < hiddenElements.length; index++) {
        var element = hiddenElements[index];
        element.removeAttribute('aria-hidden');
        element.removeAttribute(HIDDEN_FROM_ACC_TREE);
      }
    });

    return _this;
  }

  _createClass(FocusTrapZone, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._enableFocusTrapZone();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props3 = this.props,
          forceFocusInsideTrapOnComponentUpdate = _this$props3.forceFocusInsideTrapOnComponentUpdate,
          forceFocusInsideTrapOnOutsideFocus = _this$props3.forceFocusInsideTrapOnOutsideFocus,
          disabled = _this$props3.disabled;
      var doc = getDocument(this._root.current);
      var activeElement = doc.activeElement; // if after componentDidUpdate focus is not inside the focus trap, bring it back

      if (!disabled && !this._root.current.contains(activeElement) && forceFocusInsideTrapOnComponentUpdate) {
        this._bringFocusIntoZone();

        return;
      }

      var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrapOnOutsideFocus !== undefined ? prevProps.forceFocusInsideTrapOnOutsideFocus : true;
      var newForceFocusInsideTrap = forceFocusInsideTrapOnOutsideFocus !== undefined ? forceFocusInsideTrapOnOutsideFocus : true;
      var prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;
      var newDisabled = disabled !== undefined ? disabled : false;

      if (!prevForceFocusInsideTrap && newForceFocusInsideTrap || prevDisabled && !newDisabled) {
        // Transition from forceFocusInsideTrap / FTZ disabled to enabled.
        // Emulate what happens when a FocusTrapZone gets mounted.
        this._enableFocusTrapZone();
      } else if (prevForceFocusInsideTrap && !newForceFocusInsideTrap || !prevDisabled && newDisabled) {
        // Transition from forceFocusInsideTrap / FTZ enabled to disabled.
        // Emulate what happens when a FocusTrapZone gets unmounted.
        this._releaseFocusTrapZone();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // don't handle return focus unless forceFocusInsideTrapOnOutsideFocus is true or focus is still within FocusTrapZone
      var doc = getDocument(this._root.current);

      if (!this.props.disabled || this.props.forceFocusInsideTrapOnOutsideFocus || !this._root.current.contains(doc.activeElement)) {
        this._releaseFocusTrapZone();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props4 = this.props,
          className = _this$props4.className,
          forceFocusInsideTrapOnOutsideFocus = _this$props4.forceFocusInsideTrapOnOutsideFocus,
          ariaLabelledBy = _this$props4.ariaLabelledBy,
          _this$props4$disabled = _this$props4.disabled,
          disabled = _this$props4$disabled === void 0 ? false : _this$props4$disabled;
      var unhandledProps = getUnhandledProps(_keys(FocusTrapZone.propTypes), this.props);
      var ElementType = getElementType(this.props);
      var bumperProps = {
        style: {
          pointerEvents: 'none',
          position: 'fixed' // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them

        },
        tabIndex: disabled ? -1 : 0,
        // make bumpers tabbable only when enabled
        'data-is-visible': true
      };
      return React.createElement(React.Fragment, null, React.createElement(ElementType, _extends({}, unhandledProps, {
        className: className,
        ref: this.createRef,
        "aria-labelledby": ariaLabelledBy,
        onKeyDown: this._onKeyboardHandler,
        onFocusCapture: this._onFocusCapture,
        onFocus: this._onRootFocus,
        onBlur: this._onRootBlur
      }), React.createElement("div", _extends({}, bumperProps, {
        ref: this._firstBumper,
        onFocus: this._onFirstBumperFocus
      })), this.props.children, React.createElement("div", _extends({}, bumperProps, {
        ref: this._lastBumper,
        onFocus: this._onLastBumperFocus
      }))), forceFocusInsideTrapOnOutsideFocus && React.createElement(EventListener, {
        capture: true,
        listener: this._handleOutsideFocus,
        targetRef: this.windowRef,
        type: "focus"
      }), this.shouldHandleOutsideClick() && React.createElement(EventListener, {
        capture: true,
        listener: this._handleOutsideClick,
        targetRef: this.windowRef,
        type: "click"
      }));
    }
  }, {
    key: "_isBumper",
    value: function _isBumper(element) {
      return element === this._firstBumper.current || element === this._lastBumper.current;
    }
  }, {
    key: "_focusAsync",
    value: function _focusAsync(element) {
      if (!this._isBumper(element)) {
        focusAsync(element);
      }
    }
  }]);

  return FocusTrapZone;
}(React.Component);

_defineProperty(FocusTrapZone, "_focusStack", []);

_defineProperty(FocusTrapZone, "propTypes", {
  as: PropTypes.elementType,
  className: PropTypes.string,
  elementToFocusOnDismiss: PropTypes.object,
  ariaLabelledBy: PropTypes.string,
  isClickableOutsideFocusTrap: PropTypes.bool,
  ignoreExternalFocusing: PropTypes.bool,
  forceFocusInsideTrapOnOutsideFocus: PropTypes.bool,
  forceFocusInsideTrapOnComponentUpdate: PropTypes.bool,
  firstFocusableSelector: PropTypes.string,
  disableFirstFocus: PropTypes.bool,
  focusPreviouslyFocusedInnerElement: PropTypes.bool,
  focusTriggerOnOutsideClick: PropTypes.bool
});

_defineProperty(FocusTrapZone, "defaultProps", {
  as: 'div',
  isClickableOutsideFocusTrap: true,
  forceFocusInsideTrapOnOutsideFocus: false
});

export { FocusTrapZone as default };